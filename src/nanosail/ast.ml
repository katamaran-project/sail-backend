(** NanoSail AST definition *)

module Big_int = Nat_big_num


(******************************************************************************)
(* Built-in types *)

type ty_id =
  | Unit
  | Bool
  | Int
  | String
  | List
  | Prod
  | Id_nys    (* For typ ids not yet supported *)

type ty =
  | Ty_id of ty_id    (* For concrete types *)
  | Ty_app of ty_id * ty list   (* For type constructors *)
  | Ty_nys    (* For typ variants not yet supported *)

type bind = string * ty

type funType_t = {
  arg_types : bind list;
  ret_type  : ty
}


(******************************************************************************)
(* Binary operators *)

type binOp =
  (* Only Cons and Pair are generated by the sail to nanosail translator at the 
     moment *)
  | Plus
  | Times
  | Minus
  | And
  | Or
  | Pair
  | Cons
  | Append
  | Eq
  | Neq
  | Le 
  | Lt
  | Ge
  | Gt


(******************************************************************************)
(* Values *)

type value =
  | Val_unit
  | Val_bool of bool
  | Val_int of Big_int.num
  | Val_string of string
  | Val_prod of value * value
  | Val_nys   (* For value types not yet supported *)


(******************************************************************************)
(* Statements and expressions *)

type expression =
  | Exp_var of string
  | Exp_val of value
  | Exp_neg of expression  (* Not yet used by the sail to nanosail translator *)
  | Exp_not of expression  (* Not yet used by the sail to nanosail translator *)
  | Exp_list of expression list
  | Exp_binop of binOp * expression * expression
  | Exp_nys   (* For expression types not yet supported *)

type statement =
  | Stm_exp of expression
  | Stm_match_list of {   (* Simple pattern matching on list (2 cases) *)
      s        : statement;   (* Statement to match *)
      alt_nil  : statement;   (* Nil case statement *)
      xh       : string;      (* Variable name for the head of the list *)
      xt       : string;      (* Variable name for the tail of the list *)
      alt_cons : statement;   (* Cons case statement *)
    } 
  | Stm_match_prod of {   (* Simple pattern matching on product (1 case) *)
      s   : statement;    (* Statement to match *)
      xl  : string;       (* Variable name for the left term of the product *)
      xr  : string;       (* Variable name for the right tern of the product *)
      rhs : statement;    (* Resulting statement *)
    }
  | Stm_call of string * expression list    (* AST already in A-normal form *)
  | Stm_let of string * statement * statement
  | Stm_if of statement * statement * statement
  | Stm_nys   (* For statement types not yet supported *)


(******************************************************************************)
(* Function definitions *)

type funDef_t = {
  funName : string;
  funType : funType_t;
  funBody : statement;
}


(******************************************************************************)
(* Full intermediate representation *)

(** The type of the NanoSail intermediate representation. *)
type ir_t = {
  program_name : string;
  funDefList : funDef_t list;
  (* Other record fields will need to be added to extend the language (e.g. one
     for user types and one for registers). *)
}

