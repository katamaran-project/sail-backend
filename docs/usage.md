# Usage

To translate Sail to muSail, you need the following files:

* One or more Sail files that contain the code to be translated.
* A `configuration.lisp` file.
* One or more template files.
  Each template file will lead to the generation of an output file.

Next, run the following command to perform the translation.

```bash
$ sail --katamaran --katamaran-config configuration.lisp SAILFILE...
```

## Configuration File

The configuration is specified using the [Slang language](./slang.md) in `configuration.lisp`.

Below we briefly discuss the most important configuration options.
See the `Configuration` module for a more comprehensive overview.

### `template`

```lisp
; Example: machine.template.v serves as template for machine.v
(template "machine.template.v")

; Example: xxx.v serves as template for yyy.v
(template "xxx.v" "yyy.v")
```

The translator processes each given template file and writes the resulting output to a corresponding file.
The `template` function's job is to register a template file and the matching output file name.
Multiple calls can be made to register multiple input/output file pairs.
You probably want to register at least one template.

* `template` can take two arguments, e.g., `(template input-file output-file)`,
  which states that the output generated by processing `input-file` should be written to `output-file`.  
* When given a single argument, e.g., `(template input-file)`, the input file name must contain the substring `".template"`.
  The output file name is then determined by removing this substring,
  e.g., `(template "aaa.template.v")` will be paired up with `aaa.v` as output target.

### `base-name`

```lisp
; Example
(base-name "MySailModelBase")
```

`base-name` is a function that takes a single string as argument,
which will be used as the name of the base module.
If no call to `base-name` is made, the default name (`"UntitledBase"`) will be used.

### `program-name`

```lisp
; Example
(program-name "MySailModelBase")
```

Sets the name of the program module.
If no call to `program-name` is made, the default name of `"ModelProgram"` will be used.

### `include-original-code`

```lisp
; Example
(include-original-code)    ; Turns option on
(include-original-code #t) ; Turns option on
(include-original-code #f) ; Turns option off
```

This option is by default on.
Turning it off causes the generated code to be annotated
with the original Sail code.

For example,

```coq
(*
  Original Sail code
           
    val double : int -> int
    $[complete]
    function double x = $[overloaded { "name" = "*", "is_infix" = true }] mult_atom(2, x)
*)
Definition fun_double : Stm [
                              "x"  ∷  ty.int
                            ]
                            (ty.int) :=
  stm_exp (((exp_int 2%Z))*((exp_var "x"))).
```

### `annotate-functions-with-ast`

```lisp
(annotate-functions-with-ast #t) ; on
(annotate-functions-with-ast #f) ; off
(annotate-functions-with-ast)    ; on
```

Annotates functions with the nanosail AST.

```coq
    (*
      AST
        Def:Function[name=Identifier["foo"],
                     type=Def:FunctionType[parameters=[
                                                        Parameter[Identifier["x"],
                                                                  Type:Int[NumExpr:Var[Identifier["'n"]]]]
                                                      ],
                                           return_type=Type:Int[NumExpr:BinOp["Add",
                                                                              NumExpr:Var[Identifier["'n"]],
                                                                              NumExpr:Var[Identifier["'n"]]]]],
                     extended_type="TODO",
                     body=Stm:Expression[BinaryOp[Plus,
                                                  Var[Identifier["x"],
                                                      Type:Int[NumExpr:Var[Identifier["'n"]]]],
                                                  Var[Identifier["x"],
                                                      Type:Int[NumExpr:Var[Identifier["'n"]]]]]],
                     polymorphic=True,
                     monomorphs=[]]
      
      Extended type
        parameter x
          int($0)
        return value
          $0 + $0
    *)
    Definition fun_foo : Stm [
                               "x"  ∷  ty.int
                             ]
                             (ty.int) :=
      stm_exp (((exp_var "x"))+((exp_var "x"))).
```

### `inline-definitions-in-notations`

Inlines definitions.
Actived by default.
This feature was added to deal with Coq's inability to derive `NoConfusionHom` automatically for `Reg`.
For more details, see `tests/coq-tests/no-confusion-hom`.

### `monomorphize`

```lisp
(monomorphize "foo" "foo_8_8" '(
                                ("'n" 8)
                                ("'m" 8)
                                ))
```

This causes the function `foo` to 

### `$include`

```lisp
$include ../shared-configuration.lisp
```

This directive works like C's `#include` preprocessor directive.

## Template Files


## Verbosity Level

The verbosity level can be set using the environment variable `VERBOSE`:

```bash
$ VERBOSE=0 sail ...
```

* `VERBOSE=0`: quiet mode. Suppresses all logging.
* `VERBOSE=1`: only errors are shown.
* `VERBOSE=2`: only errors and warnings are shown. This is the default.
* `VERBOSE=3`
* `VERBOSE=4`: maximum level.

See `LogLib.VerbosityLevel` for more detailed information.

## HTML Generation

See [dedicated page](./html-generation.md).
