(*Generated by Sail from coq.*)
Require Import Sail.Base.
Require Import Sail.Real.
Require Import coq_types.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.


Definition eq_unit (_ : unit) (_ : unit) : bool := true.

Definition neq_int (x : Z) (y : Z) : bool := negb (Z.eqb x y).

Definition neq_bool (x : bool) (y : bool) : bool := negb (Bool.eqb x y).

Definition __id (x : Z) : Z := x.



Definition sail_mask {v0 : Z} (len : Z) (v : mword v0) (*(len >=? 0) && (v0 >=? 0)*) : mword len :=
   if Z.leb len (length_mword v) then vector_truncate v len else zero_extend v len.

Definition sail_ones (n : Z) (*n >=? 0*) : mword n := not_vec (zeros n).

Definition slice_mask (n : Z) (i : Z) (l : Z) (*n >=? 0*) : mword n :=
   if Z.geb l n then shiftl (sail_ones n) i
   else
     let one : bits n := sail_mask n (('b"1")  : bits 1) in
     shiftl (sub_vec (shiftl one l) one) i.

Definition _shl_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shl_int m n else shr_int m (Z.opp n).

Definition _shr_int_general (m : Z) (n : Z) : Z :=
   if Z.geb n 0 then shr_int m n else shl_int m (Z.opp n).

Definition fdiv_int (n : Z) (m : Z) : Z :=
   if andb (Z.ltb n 0) (Z.gtb m 0) then Z.sub (Z.quot (Z.add n 1) m) 1
   else if andb (Z.gtb n 0) (Z.ltb m 0) then Z.sub (Z.quot (Z.sub n 1) m) 1
   else Z.quot n m.

Definition fmod_int (n : Z) (m : Z) : Z := Z.sub n (Z.mul m (fdiv_int n m)).

Definition is_none {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => false | None => true end.

Definition is_some {a : Type} (opt : option a) : bool :=
   match opt with | Some _ => true | None => false end.

Definition concat_str_bits {n : Z} (str : string) (x : mword n) : string :=
   String.append str (string_of_bits x).

Definition concat_str_dec (str : string) (x : Z) : string := String.append str (dec_str x).

Definition read_kind_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 12)*) : read_kind :=
   let l__30 := arg_ in
   if Z.eqb l__30 0 then Read_plain
   else if Z.eqb l__30 1 then Read_reserve
   else if Z.eqb l__30 2 then Read_acquire
   else if Z.eqb l__30 3 then Read_exclusive
   else if Z.eqb l__30 4 then Read_exclusive_acquire
   else if Z.eqb l__30 5 then Read_stream
   else if Z.eqb l__30 6 then Read_ifetch
   else if Z.eqb l__30 7 then Read_RISCV_acquire
   else if Z.eqb l__30 8 then Read_RISCV_strong_acquire
   else if Z.eqb l__30 9 then Read_RISCV_reserved
   else if Z.eqb l__30 10 then Read_RISCV_reserved_acquire
   else if Z.eqb l__30 11 then Read_RISCV_reserved_strong_acquire
   else Read_X86_locked.

Definition num_of_read_kind (arg_ : read_kind) : Z :=
   match arg_ with
   | Read_plain => 0
   | Read_reserve => 1
   | Read_acquire => 2
   | Read_exclusive => 3
   | Read_exclusive_acquire => 4
   | Read_stream => 5
   | Read_ifetch => 6
   | Read_RISCV_acquire => 7
   | Read_RISCV_strong_acquire => 8
   | Read_RISCV_reserved => 9
   | Read_RISCV_reserved_acquire => 10
   | Read_RISCV_reserved_strong_acquire => 11
   | Read_X86_locked => 12
   end.

Definition write_kind_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 10)*) : write_kind :=
   let l__20 := arg_ in
   if Z.eqb l__20 0 then Write_plain
   else if Z.eqb l__20 1 then Write_conditional
   else if Z.eqb l__20 2 then Write_release
   else if Z.eqb l__20 3 then Write_exclusive
   else if Z.eqb l__20 4 then Write_exclusive_release
   else if Z.eqb l__20 5 then Write_RISCV_release
   else if Z.eqb l__20 6 then Write_RISCV_strong_release
   else if Z.eqb l__20 7 then Write_RISCV_conditional
   else if Z.eqb l__20 8 then Write_RISCV_conditional_release
   else if Z.eqb l__20 9 then Write_RISCV_conditional_strong_release
   else Write_X86_locked.

Definition num_of_write_kind (arg_ : write_kind) : Z :=
   match arg_ with
   | Write_plain => 0
   | Write_conditional => 1
   | Write_release => 2
   | Write_exclusive => 3
   | Write_exclusive_release => 4
   | Write_RISCV_release => 5
   | Write_RISCV_strong_release => 6
   | Write_RISCV_conditional => 7
   | Write_RISCV_conditional_release => 8
   | Write_RISCV_conditional_strong_release => 9
   | Write_X86_locked => 10
   end.

Definition a64_barrier_domain_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*)
: a64_barrier_domain :=
   let l__17 := arg_ in
   if Z.eqb l__17 0 then A64_FullShare
   else if Z.eqb l__17 1 then A64_InnerShare
   else if Z.eqb l__17 2 then A64_OuterShare
   else A64_NonShare.

Definition num_of_a64_barrier_domain (arg_ : a64_barrier_domain) : Z :=
   match arg_ with
   | A64_FullShare => 0
   | A64_InnerShare => 1
   | A64_OuterShare => 2
   | A64_NonShare => 3
   end.

Definition a64_barrier_type_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : a64_barrier_type :=
   let l__15 := arg_ in
   if Z.eqb l__15 0 then A64_barrier_all
   else if Z.eqb l__15 1 then A64_barrier_LD
   else A64_barrier_ST.

Definition num_of_a64_barrier_type (arg_ : a64_barrier_type) : Z :=
   match arg_ with | A64_barrier_all => 0 | A64_barrier_LD => 1 | A64_barrier_ST => 2 end.

Definition trans_kind_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 2)*) : trans_kind :=
   let l__13 := arg_ in
   if Z.eqb l__13 0 then Transaction_start
   else if Z.eqb l__13 1 then Transaction_commit
   else Transaction_abort.

Definition num_of_trans_kind (arg_ : trans_kind) : Z :=
   match arg_ with | Transaction_start => 0 | Transaction_commit => 1 | Transaction_abort => 2 end.

Definition cache_op_kind_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 10)*) : cache_op_kind :=
   let l__3 := arg_ in
   if Z.eqb l__3 0 then Cache_op_D_IVAC
   else if Z.eqb l__3 1 then Cache_op_D_ISW
   else if Z.eqb l__3 2 then Cache_op_D_CSW
   else if Z.eqb l__3 3 then Cache_op_D_CISW
   else if Z.eqb l__3 4 then Cache_op_D_ZVA
   else if Z.eqb l__3 5 then Cache_op_D_CVAC
   else if Z.eqb l__3 6 then Cache_op_D_CVAU
   else if Z.eqb l__3 7 then Cache_op_D_CIVAC
   else if Z.eqb l__3 8 then Cache_op_I_IALLUIS
   else if Z.eqb l__3 9 then Cache_op_I_IALLU
   else Cache_op_I_IVAU.

Definition num_of_cache_op_kind (arg_ : cache_op_kind) : Z :=
   match arg_ with
   | Cache_op_D_IVAC => 0
   | Cache_op_D_ISW => 1
   | Cache_op_D_CSW => 2
   | Cache_op_D_CISW => 3
   | Cache_op_D_ZVA => 4
   | Cache_op_D_CVAC => 5
   | Cache_op_D_CVAU => 6
   | Cache_op_D_CIVAC => 7
   | Cache_op_I_IALLUIS => 8
   | Cache_op_I_IALLU => 9
   | Cache_op_I_IVAU => 10
   end.

Definition address_size := 64.
#[export] Hint Unfold address_size : sail.
Definition integer_size := 64.
#[export] Hint Unfold integer_size : sail.
Definition cap_size := 194.
#[export] Hint Unfold cap_size : sail.
Definition Permission_of_num (arg_ : Z) (*(0 <=? arg_) && (arg_ <=? 3)*) : Permission :=
   let l__0 := arg_ in
   if Z.eqb l__0 0 then O'
   else if Z.eqb l__0 1 then R'
   else if Z.eqb l__0 2 then RW
   else E.

Definition num_of_Permission (arg_ : Permission) : Z :=
   match arg_ with | O' => 0 | R' => 1 | RW => 2 | E => 3 end.

Definition regname (i : Z) : string := concat_str_dec "R" i.

Definition nextPC '(tt : unit) : M (Capability) :=
   read_reg PC_ref >>= fun (w__0 : Capability) =>
   let cursor := w__0.(Capability_cap_cursor) in
   read_reg PC_ref >>= fun (w__1 : Capability) =>
   returnM {[ w__1 with Capability_cap_cursor := add_vec_int cursor 4 ]}.

Definition updatePC '(tt : unit) : M (unit) :=
   (nextPC tt) >>= fun c => write_reg PC_ref c  : M (unit).

Definition addPC (offset : mword 64) : M (unit) :=
   read_reg PC_ref >>= fun (w__0 : Capability) =>
   let cursor := w__0.(Capability_cap_cursor) in
   read_reg PC_ref >>= fun (w__1 : Capability) =>
   write_reg PC_ref {[ w__1 with Capability_cap_cursor := add_vec cursor offset ]}
    : M (unit).

Definition MEMw (addr : mword 64) (v : word) : bool := true.

Definition MEMr (addr : mword 64) : word := Num (zeros integer_size).

Definition MEMri (addr : mword 64) : mword 32 := zeros 32.

Definition default_capability : Capability :=
{| Capability_cap_permission := RW;
   Capability_cap_begin := zeros 64;
   Capability_cap_end := (Ox"FFFFFFFFFFFFFFFF")  : mword 64;
   Capability_cap_cursor := zeros 64 |}.
#[export] Hint Unfold default_capability : sail.
Definition is_sub_perm (p : Permission) (p' : Permission) : bool :=
   match p with
   | O' => true
   | E => match p' with | O' => false | _ => true end
   | R' => match p' with | O' => false | E => false | _ => true end
   | RW => match p' with | RW => true | _ => false end
   end.

Definition writeAllowed (p : Permission) : bool := is_sub_perm RW p.

Definition readAllowed (p : Permission) : bool := is_sub_perm R' p.

Definition withinBounds (c : Capability) : bool :=
   let cursor := uint c.(Capability_cap_cursor) in
   let begin := uint c.(Capability_cap_begin) in
   let top := uint c.(Capability_cap_end) in
   andb (Z.leb begin cursor) (Z.leb cursor top).

Definition isWithinRange (b' : mword 64) (e' : mword 64) (b : mword 64) (e : mword 64) : bool :=
   andb (Z.leb (uint b) (uint b')) ((Z.leb (uint e') (uint e))  : bool).

Definition read_mem' (c : Capability) : M (word) :=
   let p := readAllowed c.(Capability_cap_permission) in
   assert_exp' p "Err: [read_mem] no read permission" >>= fun _ =>
   let q := withinBounds c in
   assert_exp' q "Err: [read_mem] out of bounds" >>= fun _ =>
   returnM (MEMr c.(Capability_cap_cursor)).

Definition write_mem' (c : Capability) (w : word) : M (unit) :=
   let p := writeAllowed c.(Capability_cap_permission) in
   assert_exp' p "Err: [write_mem] no read permission" >>= fun _ =>
   let q := withinBounds c in
   assert_exp' q "Err: [write_mem] out of bounds" >>= fun _ =>
   (assert_exp (MEMw c.(Capability_cap_cursor) w) "./capabilities.sail:58.30-58.31")
    : M (unit).

Definition permToString (p : Permission) : string :=
   match p with | O' => "O " | E => "E " | R' => "R " | RW => "RW" end.

Definition perm_bits_forwards (arg_ : Permission) : M (mword 3) :=
   returnM
   (match arg_ with
    | O' => ('b"000")  : mword 3
    | R' => ('b"010")  : mword 3
    | RW => ('b"011")  : mword 3
    | E => ('b"100")  : mword 3
    end).

Definition perm_bits_backwards (arg_ : mword 3) : M (Permission) :=
   let b__0 := arg_ in
   (if eq_vec b__0 (('b"000")  : mword 3) then returnM O'
    else if eq_vec b__0 (('b"010")  : mword 3) then returnM R'
    else if eq_vec b__0 (('b"011")  : mword 3) then returnM RW
    else if eq_vec b__0 (('b"100")  : mword 3) then returnM E
    else assert_exp' false "Pattern match failure at unknown location" >>= fun _ => exit tt)
    : M (Permission).

Definition perm_bits_forwards_matches (arg_ : Permission) : M (bool) :=
   returnM (match arg_ with | O' => true | R' => true | RW => true | E => true end).

Definition perm_bits_backwards_matches (arg_ : mword 3) : M (bool) :=
   returnM
   (let b__0 := arg_ in
   if eq_vec b__0 (('b"000")  : mword 3) then true
   else if eq_vec b__0 (('b"010")  : mword 3) then true
   else if eq_vec b__0 (('b"011")  : mword 3) then true
   else if eq_vec b__0 (('b"100")  : mword 3) then true
   else false).

Definition capToString (c : Capability) : string :=
   String.append "perm: "
     (String.append (permToString c.(Capability_cap_permission))
        (String.append " begin: "
           (String.append (string_of_bits c.(Capability_cap_begin))
              (String.append " end: "
                 (String.append (string_of_bits c.(Capability_cap_end))
                    (String.append " cursor: " (string_of_bits c.(Capability_cap_cursor)))))))).

Definition imm_size := 12.
#[export] Hint Unfold imm_size : sail.
Definition imm_ext_size := 20.
#[export] Hint Unfold imm_ext_size : sail.
Definition writeReg (rs : mword 2) (w : word) : M (unit) :=
   let b__0 := rs in
   (if eq_vec b__0 (('b"00")  : mword 2) return M (unit) then write_reg R0_ref w  : M (unit)
    else if eq_vec b__0 (('b"01")  : mword 2) return M (unit) then write_reg R1_ref w  : M (unit)
    else if eq_vec b__0 (('b"10")  : mword 2) return M (unit) then write_reg R2_ref w  : M (unit)
    else write_reg R3_ref w  : M (unit))
    : M (unit).

Definition readReg (rs : mword 2) : M (word) :=
   let b__0 := rs in
   (if eq_vec b__0 (('b"00")  : mword 2) then returnM (Num (zeros integer_size))
    else if eq_vec b__0 (('b"01")  : mword 2) return M (word) then read_reg R1_ref  : M (word)
    else if eq_vec b__0 (('b"10")  : mword 2) return M (word) then read_reg R2_ref  : M (word)
    else read_reg R3_ref  : M (word))
    : M (word).

Definition readRegCap (cs : mword 2) : M (Capability) :=
   (readReg cs) >>= fun w =>
   (match w with | Cap c => returnM c | _ => throw (ExpectedCapabilityRegisterContents tt) end)
    : M (Capability).

Definition readRegNum (rs : mword 2) : M (mword 64) :=
   (readReg rs) >>= fun w =>
   (match w with | Num i => returnM i | _ => throw (ExpectedNumberRegisterContents tt) end)
    : M (mword 64).

Definition isPerm (p : Permission) (p' : Permission) : bool :=
   match p with
   | O' => match p' with | O' => true | _ => false end
   | R' => match p' with | R' => true | _ => false end
   | RW => match p' with | RW => true | _ => false end
   | E => match p' with | E => true | _ => false end
   end.

Definition isNotZero (i : mword 12) : bool := neq_vec i (zeros imm_size).

Definition canIncrCursor (c : Capability) (imm : mword 12) : bool :=
   orb (negb (isPerm c.(Capability_cap_permission) E)) (negb (isNotZero imm)).

Definition updatePCPerm (c : Capability) : Capability :=
   match c.(Capability_cap_permission) with
   | E => {[ c with Capability_cap_permission := R' ]}
   | _ => c
   end.

Definition execute_SUB (rd : mword 2) (rs1 : mword 2) (rs2 : mword 2) : M (bool) :=
   (readRegNum rs1) >>= fun v1 =>
   (readRegNum rs2) >>= fun v2 =>
   let res := Z.sub (sint v1) (sint v2) in
   (writeReg rd (Num (get_slice_int integer_size res 0))) >> (updatePC tt) >> returnM true.

Definition execute_SLTU (rd : mword 2) (rs : mword 2) (rb : mword 2) : M (bool) :=
   (readRegNum rs) >>= fun v1 =>
   let uv1 := uint v1 in
   (readRegNum rb) >>= fun v2 =>
   let uv2 := uint v2 in
   (if Z.ltb uv1 uv2 return M (unit) then
      (writeReg rd (Num (zero_extend (('b"1")  : mword 1) integer_size)))
       : M (unit)
    else (writeReg rd (Num (zero_extend (('b"0")  : mword 1) integer_size)))  : M (unit)) >>
   (updatePC tt) >> returnM true.

Definition execute_SLTIU (rd : mword 2) (rs : mword 2) (immediate : mword 12) : M (bool) :=
   (readRegNum rs) >>= fun v1 =>
   let uv1 := uint v1 in
   let v2 := sign_extend immediate integer_size in
   let uv2 := uint v2 in
   (if Z.ltb uv1 uv2 return M (unit) then
      (writeReg rd (Num (zero_extend (('b"1")  : mword 1) integer_size)))
       : M (unit)
    else (writeReg rd (Num (zero_extend (('b"0")  : mword 1) integer_size)))  : M (unit)) >>
   (updatePC tt) >> returnM true.

Definition execute_SLTI (rd : mword 2) (rs : mword 2) (imm : mword 12) : M (bool) :=
   (readRegNum rs) >>= fun v1 =>
   let v2 := sign_extend imm integer_size in
   (if Z.ltb (sint v1) (sint v2) return M (unit) then
      (writeReg rd (Num (zero_extend (('b"1")  : mword 1) integer_size)))
       : M (unit)
    else (writeReg rd (Num (zero_extend (('b"0")  : mword 1) integer_size)))  : M (unit)) >>
   (updatePC tt) >> returnM true.

Definition execute_SLT (rd : mword 2) (rs1 : mword 2) (rs2 : mword 2) : M (bool) :=
   (readRegNum rs1) >>= fun v1 =>
   (readRegNum rs2) >>= fun v2 =>
   (if Z.ltb (sint v1) (sint v2) return M (unit) then
      (writeReg rd (Num (zero_extend (('b"1")  : mword 1) integer_size)))
       : M (unit)
    else (writeReg rd (Num (zero_extend (('b"0")  : mword 1) integer_size)))  : M (unit)) >>
   (updatePC tt) >> returnM true.

Definition execute_SD (rs1 : mword 2) (rs2 : mword 2) (imm : mword 12) : M (bool) :=
   (readRegCap rs1) >>= fun base_cap =>
   let c :=
     {[ base_cap with
       Capability_cap_cursor :=
         add_vec base_cap.(Capability_cap_cursor) (sign_extend imm integer_size) ]} in
   assert_exp (writeAllowed c.(Capability_cap_permission)) "Err: [store] no read permission" >>
   (readReg rs2) >>= fun w => (write_mem' c w) >> (updatePC tt) >> returnM true.

Definition execute_RET '(tt : unit) : M (bool) := returnM (false).

Definition execute_LD (cd : mword 2) (cs : mword 2) (imm : mword 12) : M (bool) :=
   (readRegCap cs) >>= fun base_cap =>
   let c :=
     {[ base_cap with
       Capability_cap_cursor :=
         add_vec base_cap.(Capability_cap_cursor) (sign_extend imm integer_size) ]} in
   assert_exp (readAllowed c.(Capability_cap_permission)) "Err: [load] no read permission" >>
   (read_mem' c) >>= fun n => (writeReg cd n) >> (updatePC tt) >> returnM true.

Definition execute_CJALR (cd : mword 2) (cs : mword 2) (imm : mword 12) : M (bool) :=
   (nextPC tt) >>= fun npc =>
   (writeReg cd (Cap npc)) >>
   (readRegCap cs) >>= fun c =>
   (if negb (canIncrCursor c imm) return M (bool) then throw (CapabilityCursorCannotBeModified tt)
    else
      let imm := zero_extend imm integer_size in
      let c' :=
        updatePCPerm {[ c with Capability_cap_cursor := add_vec c.(Capability_cap_cursor) imm ]} in
      write_reg PC_ref c' >> returnM true)
    : M (bool).

Definition execute_JALR_CAP (cd : mword 2) (cs : mword 2) : M (bool) :=
   (execute_CJALR cd cs (zeros imm_size))  : M (bool).

Definition execute_FAIL '(tt : unit) : M (bool) := throw (Fail tt).

Definition execute_CSETBOUNDSIMM (cd : mword 2) (cs : mword 2) (imm : mword 12) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   let new_begin := c.(Capability_cap_cursor) in
   let new_end := add_vec new_begin (zero_extend imm integer_size) in
   (match c.(Capability_cap_permission) with
    | E => throw (CSETBOUNDSOnEnterCapability tt)
    | _ =>
       let b := isWithinRange new_begin new_end c.(Capability_cap_begin) c.(Capability_cap_end) in
       assert_exp' b "Err: [csetbounds] tried to increase range of authority" >>= fun _ =>
       let c' :=
         {| Capability_cap_permission := c.(Capability_cap_permission);
            Capability_cap_begin := new_begin;
            Capability_cap_end := new_end;
            Capability_cap_cursor := c.(Capability_cap_cursor) |} in
       (writeReg cd (Cap c')) >> (updatePC tt) >> returnM true
    end)
    : M (bool).

Definition execute_CSETBOUNDS (cd : mword 2) (cs : mword 2) (rs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   let new_begin := c.(Capability_cap_cursor) in
   (readRegNum rs) >>= fun rs_val =>
   let new_end := add_vec new_begin rs_val in
   (match c.(Capability_cap_permission) with
    | E => throw (CSETBOUNDSOnEnterCapability tt)
    | _ =>
       let b := isWithinRange new_begin new_end c.(Capability_cap_begin) c.(Capability_cap_end) in
       assert_exp' b "Err: [csetbounds] tried to increase range of authority" >>= fun _ =>
       let c' :=
         {| Capability_cap_permission := c.(Capability_cap_permission);
            Capability_cap_begin := new_begin;
            Capability_cap_end := new_end;
            Capability_cap_cursor := c.(Capability_cap_cursor) |} in
       (writeReg cd (Cap c')) >> (updatePC tt) >> returnM true
    end)
    : M (bool).

Definition execute_CMOVE (cd : mword 2) (cs : mword 2) : M (bool) :=
   (readReg cs) >>= fun (w__0 : word) => (writeReg cd w__0) >> (updatePC tt) >> returnM true.

Definition execute_CJAL (cd : mword 2) (imm : mword 20) : M (bool) :=
   (nextPC tt) >>= fun npc =>
   (writeReg cd (Cap npc)) >> (addPC (shiftl (zero_extend imm integer_size) 1)) >> returnM true.

Definition execute_CINCOFFSET (cd : mword 2) (cs : mword 2) (rs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun base_cap =>
   (readRegNum rs) >>= fun offset =>
   (match base_cap.(Capability_cap_permission) with
    | E => throw (CINCOFFSETOnEnterCapability tt)
    | _ =>
       let c :=
         {[ base_cap with Capability_cap_cursor := add_vec base_cap.(Capability_cap_cursor) offset ]} in
       (writeReg cd (Cap c)) >> (updatePC tt) >> returnM true
    end)
    : M (bool).

Definition execute_CGETTAG (rd : mword 2) (cs : mword 2) : M (bool) :=
   (readReg cs) >>= fun w =>
   (match w with
    | Num _ => (writeReg rd (Num (zero_extend (('b"0")  : mword 1) integer_size)))  : M (unit)
    | Cap _ => (writeReg rd (Num (zero_extend (('b"1")  : mword 1) integer_size)))  : M (unit)
    end) >>
   (updatePC tt) >> returnM true.

Definition execute_CGETPERM (rd : mword 2) (cs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   (perm_bits_forwards c.(Capability_cap_permission)) >>= fun (w__0 : mword 3) =>
   let i := zero_extend w__0 integer_size in
   (writeReg rd (Num i)) >> (updatePC tt) >> returnM true.

Definition execute_CGETLEN (rd : mword 2) (cs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   let res := sub_vec c.(Capability_cap_end) c.(Capability_cap_begin) in
   (writeReg rd (Num res)) >> (updatePC tt) >> returnM true.

Definition execute_CGETBASE (rd : mword 2) (cs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   (writeReg rd (Num c.(Capability_cap_begin))) >> (updatePC tt) >> returnM true.

Definition execute_CGETADDR (rd : mword 2) (cs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun c =>
   (writeReg rd (Num c.(Capability_cap_cursor))) >> (updatePC tt) >> returnM true.

Definition execute_CANDPERM (cd : mword 2) (cs : mword 2) (rs : mword 2) : M (bool) :=
   (readRegCap cs) >>= fun cs_val =>
   (readRegNum rs) >>= fun rs_val =>
   (perm_bits_forwards cs_val.(Capability_cap_permission)) >>= fun p =>
   let p' := subrange_vec_dec rs_val 2 0 in
   (perm_bits_backwards (and_vec p p')) >>= fun new_p =>
   let new_cap := {[ cs_val with Capability_cap_permission := new_p ]} in
   (writeReg cd (Cap new_cap)) >> (updatePC tt) >> returnM true.

Definition execute_BNE (rs1 : mword 2) (rs2 : mword 2) (imm : mword 12) : M (bool) :=
   (readRegNum rs1) >>= fun a =>
   (readRegNum rs2) >>= fun b =>
   (if eq_vec a b return M (unit) then (updatePC tt)  : M (unit)
    else (addPC (zero_extend imm integer_size))  : M (unit)) >>
   returnM true.

Definition execute_ADDI (rd : mword 2) (rs : mword 2) (imm : mword 12) : M (bool) :=
   (readRegNum rs) >>= fun v =>
   let res := add_vec v (sign_extend imm integer_size) in
   (writeReg rd (Num res)) >> (updatePC tt) >> returnM true.

Definition execute_ADD (rd : mword 2) (rs1 : mword 2) (rs2 : mword 2) : M (bool) :=
   (readRegNum rs1) >>= fun v1 =>
   (readRegNum rs2) >>= fun v2 =>
   let res := add_vec v1 v2 in
   (writeReg rd (Num res)) >> (updatePC tt) >> returnM true.

Definition execute (merge_var : ast) : M (bool) :=
   (match merge_var with
    | JALR_CAP (cd, cs) => (execute_JALR_CAP cd cs)  : M (bool)
    | CJALR (cd, cs, imm) => (execute_CJALR cd cs imm)  : M (bool)
    | CJAL (cd, imm) => (execute_CJAL cd imm)  : M (bool)
    | BNE (rs1, rs2, imm) => (execute_BNE rs1 rs2 imm)  : M (bool)
    | CMOVE (cd, cs) => (execute_CMOVE cd cs)  : M (bool)
    | CGETTAG (rd, cs) => (execute_CGETTAG rd cs)  : M (bool)
    | CGETPERM (rd, cs) => (execute_CGETPERM rd cs)  : M (bool)
    | CGETBASE (rd, cs) => (execute_CGETBASE rd cs)  : M (bool)
    | CGETLEN (rd, cs) => (execute_CGETLEN rd cs)  : M (bool)
    | CGETADDR (rd, cs) => (execute_CGETADDR rd cs)  : M (bool)
    | SD (rs1, rs2, imm) => (execute_SD rs1 rs2 imm)  : M (bool)
    | LD (cd, cs, imm) => (execute_LD cd cs imm)  : M (bool)
    | CINCOFFSET (cd, cs, rs) => (execute_CINCOFFSET cd cs rs)  : M (bool)
    | CANDPERM (cd, cs, rs) => (execute_CANDPERM cd cs rs)  : M (bool)
    | ADDI (rd, rs, imm) => (execute_ADDI rd rs imm)  : M (bool)
    | ADD (rd, rs1, rs2) => (execute_ADD rd rs1 rs2)  : M (bool)
    | SUB (rd, rs1, rs2) => (execute_SUB rd rs1 rs2)  : M (bool)
    | SLT (rd, rs1, rs2) => (execute_SLT rd rs1 rs2)  : M (bool)
    | SLTI (rd, rs, imm) => (execute_SLTI rd rs imm)  : M (bool)
    | SLTU (rd, rs, rb) => (execute_SLTU rd rs rb)  : M (bool)
    | SLTIU (rd, rs, immediate) => (execute_SLTIU rd rs immediate)  : M (bool)
    | CSETBOUNDS (cd, cs, rs) => (execute_CSETBOUNDS cd cs rs)  : M (bool)
    | CSETBOUNDSIMM (cd, cs, imm) => (execute_CSETBOUNDSIMM cd cs imm)  : M (bool)
    | RET arg0 => (execute_RET arg0)  : M (bool)
    | FAIL arg0 => (execute_FAIL arg0)  : M (bool)
    end)
    : M (bool).

Definition tREG (rs : mword 5) : mword 2 :=
   let b__0 := rs in
   if eq_vec b__0 (('b"01010")  : mword 5) then ('b"00")  : mword 2
   else if eq_vec b__0 (('b"01011")  : mword 5) then ('b"01")  : mword 2
   else if eq_vec b__0 (('b"01100")  : mword 5) then ('b"10")  : mword 2
   else if eq_vec b__0 (('b"01101")  : mword 5) then ('b"11")  : mword 2
   else ('b"00")  : mword 2.

Definition decode (v__0 : mword 32) : option ast :=
   if eq_vec v__0 ((Ox"00008067")  : mword 32) then Some (RET tt)
   else if eq_vec v__0 ((Ox"00000067")  : mword 32) then Some (FAIL tt)
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"FEC")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1)))) then
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (JALR_CAP (tREG cd, tREG cs))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"1100111")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CJALR (tREG cd, tREG cs, imm))
   else if eq_vec (subrange_vec_dec v__0 6 0) (('b"1101111")  : mword (6 - 0 + 1)) then
     let imm_19 : bits 1 := subrange_vec_dec v__0 31 31 in
     let imm_8 : bits 1 := subrange_vec_dec v__0 20 20 in
     let imm_7_0 : bits 8 := subrange_vec_dec v__0 19 12 in
     let imm_19 : bits 1 := subrange_vec_dec v__0 31 31 in
     let imm_18_13 : bits 6 := subrange_vec_dec v__0 30 25 in
     let imm_12_9 : bits 4 := subrange_vec_dec v__0 24 21 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some
       (CJAL
          (tREG cd, concat_vec imm_19
                      (concat_vec imm_7_0 (concat_vec imm_8 (concat_vec imm_18_13 imm_12_9)))))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"001")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"1100011")  : mword (6 - 0 + 1))) then
     let imm7_6 : bits 1 := subrange_vec_dec v__0 31 31 in
     let rs2 : bits 5 := subrange_vec_dec v__0 24 20 in
     let rs1 : bits 5 := subrange_vec_dec v__0 19 15 in
     let imm7_6 : bits 1 := subrange_vec_dec v__0 31 31 in
     let imm7_5_0 : bits 6 := subrange_vec_dec v__0 30 25 in
     let imm5_4_1 : bits 4 := subrange_vec_dec v__0 11 8 in
     let imm5_0 : bits 1 := subrange_vec_dec v__0 7 7 in
     Some
       (BNE
          (tREG rs1, tREG rs2, concat_vec imm7_6 (concat_vec imm5_0 (concat_vec imm7_5_0 imm5_4_1))))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"FEA")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1)))) then
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CMOVE (tREG cd, tREG cs))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"011")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"0000011")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     Some (LD (tREG rd, tREG rs, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"011")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"0100011")  : mword (6 - 0 + 1))) then
     let imm1 : bits 7 := subrange_vec_dec v__0 31 25 in
     let rs : bits 5 := subrange_vec_dec v__0 24 20 in
     let rb : bits 5 := subrange_vec_dec v__0 19 15 in
     let imm2 : bits 5 := subrange_vec_dec v__0 11 7 in
     let imm1 : bits 7 := subrange_vec_dec v__0 31 25 in
     Some (SD (tREG rs, tREG rb, concat_vec imm1 imm2))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"0010011")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     Some (ADDI (tREG rd, tREG rs, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0000000")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let rb : bits 5 := subrange_vec_dec v__0 24 20 in
     Some (ADD (tREG rd, tREG rs, tREG rb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0100000")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let rb : bits 5 := subrange_vec_dec v__0 24 20 in
     Some (SUB (tREG rd, tREG rs, tREG rb))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"400")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"101")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CGETPERM (tREG rd, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"401")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"101")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CGETBASE (tREG rd, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"402")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"101")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CGETLEN (tREG rd, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"403")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"101")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CGETADDR (tREG rd, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0010001")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 24 20 in
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CINCOFFSET (tREG cd, tREG cs, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 20) ((Ox"405")  : mword (31 - 20 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"101")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CGETTAG (tREG rd, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0001101")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 24 20 in
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CANDPERM (tREG cd, tREG cs, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0000000")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"010")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let rb : bits 5 := subrange_vec_dec v__0 24 20 in
     Some (SLT (tREG rd, tREG rs, tREG rb))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"010")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"0010011")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     Some (SLTI (tREG rd, tREG rs, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0000000")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"011")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"0110011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let rb : bits 5 := subrange_vec_dec v__0 24 20 in
     Some (SLTU (tREG rd, tREG rs, tREG rb))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"011")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"0010011")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let rs : bits 5 := subrange_vec_dec v__0 19 15 in
     let rd : bits 5 := subrange_vec_dec v__0 11 7 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     Some (SLTIU (tREG rd, tREG rs, imm))
   else if andb (eq_vec (subrange_vec_dec v__0 31 25) (('b"0001000")  : mword (31 - 25 + 1)))
             (andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"000")  : mword (14 - 12 + 1)))
                (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1)))) then
     let rs : bits 5 := subrange_vec_dec v__0 24 20 in
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CSETBOUNDS (tREG cd, tREG cs, tREG rs))
   else if andb (eq_vec (subrange_vec_dec v__0 14 12) (('b"010")  : mword (14 - 12 + 1)))
             (eq_vec (subrange_vec_dec v__0 6 0) (('b"1011011")  : mword (6 - 0 + 1))) then
     let imm : imm := subrange_vec_dec v__0 31 20 in
     let imm : coq_types.imm := subrange_vec_dec v__0 31 20 in
     let cs : bits 5 := subrange_vec_dec v__0 19 15 in
     let cd : bits 5 := subrange_vec_dec v__0 11 7 in
     Some (CSETBOUNDSIMM (tREG cd, tREG cs, imm))
   else None.

Definition wordToString (w : word) : string :=
   match w with
   | Cap c => String.append "[Capability] " (capToString c)
   | Num n => String.append "[Integer]    " (string_of_bits n)
   end.

Definition print_register_dump '(tt : unit) : unit := tt.

Definition cycle_limit_reached '(tt : unit) : bool := false.

Definition init_registers (initialPC : mword 64) : M (unit) :=
   write_reg PC_ref default_capability >>
   read_reg PC_ref >>= fun (w__0 : Capability) =>
   write_reg PC_ref {[ w__0 with Capability_cap_cursor := initialPC ]} >>
   write_reg R0_ref (Cap default_capability)
    : M (unit).

Definition fetch_and_execute '(tt : unit) : M (bool) :=
   (and_boolM
      (read_reg PC_ref >>= fun (w__0 : Capability) =>
       returnM ((readAllowed w__0.(Capability_cap_permission))  : bool))
      (read_reg PC_ref >>= fun (w__1 : Capability) => returnM ((withinBounds w__1)  : bool))) >>= fun (w__2 : bool) =>
   (if w__2 return M (bool) then
      read_reg PC_ref >>= fun (w__3 : Capability) =>
      let instr := MEMri w__3.(Capability_cap_cursor) in
      read_reg instr_count_ref >>= fun (w__4 : Z) =>
      write_reg instr_count_ref (Z.add w__4 1) >>
      read_reg PC_ref >>= fun (w__5 : Capability) =>
      let '(_) := (print_bits "pc: " w__5.(Capability_cap_cursor))  : unit in
      let '(_) := (print_bits "instr: " instr)  : unit in
      (match (decode instr) with
       | Some ast => (execute ast)  : M (bool)
       | None =>
          let '(_) := (print_endline "invalid instruction")  : unit in
          returnM false
       end) >>= fun (loop_again : bool) =>
      returnM (andb loop_again (negb (cycle_limit_reached tt)))
    else returnM false)
    : M (bool).

Definition main '(tt : unit) : M (unit) :=
   write_reg instr_count_ref 0 >>
   (init_registers (get_slice_int 64 (elf_entry tt) 0)) >>
   (whileM
     tt
     (fun _ => ((fetch_and_execute tt)  : M (bool))  : M (bool))
     (fun _ => returnM (tt  : unit))) >>
   let '(_) := (print_endline "Machine Output")  : unit in
   let '(_) := (print_register_dump tt)  : unit in
   read_reg instr_count_ref >>= fun (w__1 : Z) =>
   returnM (print_endline (concat_str_dec "Instruction Count: " w__1)).

Definition initial_Capability : Capability :=
{| Capability_cap_permission := O';
   Capability_cap_begin := (Ox"0000000000000000")  : mword 64;
   Capability_cap_end := (Ox"0000000000000000")  : mword 64;
   Capability_cap_cursor := (Ox"0000000000000000")  : mword 64 |}.
#[export] Hint Unfold initial_Capability : sail.
Definition initial_regstate : regstate :=
{| instr_count := 0;
   R3 := Cap initial_Capability;
   R2 := Cap initial_Capability;
   R1 := Cap initial_Capability;
   R0 := Cap initial_Capability;
   PC := initial_Capability |}.
#[export] Hint Unfold initial_regstate : sail.


