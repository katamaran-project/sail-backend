(*Generated by Sail from coq.*)
Require Import Sail.Base.
Require Import Sail.Real.
Import ListNotations.
Open Scope string.
Open Scope bool.
Open Scope Z.

Definition bits (n : Z) : Type := mword n.

Inductive regfp :=
| RFull : string -> regfp
| RSlice : (string * Z * Z) -> regfp
| RSliceBit : (string * Z) -> regfp
| RField : (string * string) -> regfp.
Arguments regfp : clear implicits.

#[export]
Instance dummy_regfp : Inhabited (regfp) := { inhabitant := RFull inhabitant }.

Definition regfps : Type := list regfp.

Inductive niafp :=
| NIAFP_successor : unit -> niafp
| NIAFP_concrete_address : bits 64 -> niafp
| NIAFP_indirect_address : unit -> niafp.
Arguments niafp : clear implicits.

#[export]
Instance dummy_niafp : Inhabited (niafp) := { inhabitant := NIAFP_successor inhabitant }.

Definition niafps : Type := list niafp.

Inductive diafp :=
| DIAFP_none : unit -> diafp
| DIAFP_concrete : bits 64 -> diafp
| DIAFP_reg : regfp -> diafp.
Arguments diafp : clear implicits.

#[export]
Instance dummy_diafp : Inhabited (diafp) := { inhabitant := DIAFP_none inhabitant }.

Definition address : Type := bits 64.

Definition integer : Type := bits 64.

Definition cap_bits : Type := bits 194.

Inductive Permission := O' | R' | RW | E.
Scheme Equality for Permission.
#[export]
Instance Decidable_eq_Permission : forall (x y : Permission), Decidable (x = y) :=
  Decidable_eq_from_dec Permission_eq_dec.
#[export]
Instance dummy_Permission : Inhabited Permission := { inhabitant := O' }.


Definition instruction : Type := bits 32.

Record Capability := {
  Capability_cap_permission : Permission;
  Capability_cap_begin : address;
  Capability_cap_end : address;
  Capability_cap_cursor : address;
}.
Arguments Capability : clear implicits.
Notation "{[ r 'with' 'Capability_cap_permission' := e ]}" :=
  match r with Build_Capability _ f1 f2 f3 => Build_Capability e f1 f2 f3 end.
Notation "{[ r 'with' 'Capability_cap_begin' := e ]}" :=
  match r with Build_Capability f0 _ f2 f3 => Build_Capability f0 e f2 f3 end.
Notation "{[ r 'with' 'Capability_cap_end' := e ]}" :=
  match r with Build_Capability f0 f1 _ f3 => Build_Capability f0 f1 e f3 end.
Notation "{[ r 'with' 'Capability_cap_cursor' := e ]}" :=
  match r with Build_Capability f0 f1 f2 _ => Build_Capability f0 f1 f2 e end.
#[export]
Instance dummy_Capability : Inhabited (Capability ) := {
  inhabitant := {|
    Capability_cap_permission := inhabitant;
    Capability_cap_begin := inhabitant;
    Capability_cap_end := inhabitant;
    Capability_cap_cursor := inhabitant
|} }.


Inductive word :=
| Cap : Capability -> word
| Num : integer -> word.
Arguments word : clear implicits.

#[export]
Instance dummy_word : Inhabited (word) := { inhabitant := Cap inhabitant }.

Inductive exception :=
| ExpectedCapabilityRegisterContents : unit -> exception
| ExpectedNumberRegisterContents : unit -> exception
| CapabilityDoesNotHaveWritePermission : unit -> exception
| CapabilityCursorCannotBeModified : unit -> exception
| CINCOFFSETOnEnterCapability : unit -> exception
| CSETBOUNDSOnEnterCapability : unit -> exception
| Fail : unit -> exception.
Arguments exception : clear implicits.

#[export]
Instance dummy_exception : Inhabited (exception) := {
  inhabitant := ExpectedCapabilityRegisterContents inhabitant
}.

Definition regname : Type := bits 2.

Definition dst : Type := regname.

Definition src : Type := regname.

Definition imm : Type := bits 12.

Definition imm_ext : Type := bits 20.

Inductive ast :=
| JALR_CAP : (dst * src) -> ast
| CJALR : (dst * src * imm) -> ast
| CJAL : (dst * imm_ext) -> ast
| BNE : (src * src * imm) -> ast
| LD : (dst * src * imm) -> ast
| SD : (src * src * imm) -> ast
| ADDI : (dst * src * imm) -> ast
| ADD : (dst * src * src) -> ast
| SUB : (dst * src * src) -> ast
| SLT : (dst * src * src) -> ast
| SLTI : (dst * src * imm) -> ast
| SLTIU : (dst * src * imm) -> ast
| SLTU : (dst * src * src) -> ast
| CMOVE : (dst * src) -> ast
| CINCOFFSET : (dst * src * src) -> ast
| CANDPERM : (dst * src * src) -> ast
| CSETBOUNDS : (dst * src * src) -> ast
| CSETBOUNDSIMM : (dst * src * imm) -> ast
| CGETTAG : (dst * src) -> ast
| CGETPERM : (dst * src) -> ast
| CGETBASE : (dst * src) -> ast
| CGETLEN : (dst * src) -> ast
| CGETADDR : (dst * src) -> ast
| FAIL : unit -> ast
| RET : unit -> ast.
Arguments ast : clear implicits.

#[export]
Instance dummy_ast : Inhabited (ast) := { inhabitant := JALR_CAP inhabitant }.

Inductive register_value :=
| Regval_vector : list register_value -> register_value
| Regval_list : list register_value -> register_value
| Regval_option : option register_value -> register_value
| Regval_bool : bool -> register_value
| Regval_int : Z -> register_value
| Regval_real : R -> register_value
| Regval_string : string -> register_value
| Regval_Capability : Capability -> register_value
| Regval_bit : bitU -> register_value
| Regval_word : word -> register_value.
Arguments register_value : clear implicits.

#[export]
Instance dummy_register_value : Inhabited (register_value) := {
  inhabitant := Regval_vector inhabitant
}.

Record regstate := {
  instr_count : Z;
  R3 : word;
  R2 : word;
  R1 : word;
  R0 : word;
  PC : Capability;
}.
Arguments regstate : clear implicits.
Notation "{[ r 'with' 'instr_count' := e ]}" :=
  match r with Build_regstate _ f1 f2 f3 f4 f5 => Build_regstate e f1 f2 f3 f4 f5 end.
Notation "{[ r 'with' 'R3' := e ]}" :=
  match r with Build_regstate f0 _ f2 f3 f4 f5 => Build_regstate f0 e f2 f3 f4 f5 end.
Notation "{[ r 'with' 'R2' := e ]}" :=
  match r with Build_regstate f0 f1 _ f3 f4 f5 => Build_regstate f0 f1 e f3 f4 f5 end.
Notation "{[ r 'with' 'R1' := e ]}" :=
  match r with Build_regstate f0 f1 f2 _ f4 f5 => Build_regstate f0 f1 f2 e f4 f5 end.
Notation "{[ r 'with' 'R0' := e ]}" :=
  match r with Build_regstate f0 f1 f2 f3 _ f5 => Build_regstate f0 f1 f2 f3 e f5 end.
Notation "{[ r 'with' 'PC' := e ]}" :=
  match r with Build_regstate f0 f1 f2 f3 f4 _ => Build_regstate f0 f1 f2 f3 f4 e end.
#[export]
Instance dummy_regstate : Inhabited (regstate ) := {
  inhabitant := {|
    instr_count := inhabitant;
    R3 := inhabitant;
    R2 := inhabitant;
    R1 := inhabitant;
    R0 := inhabitant;
    PC := inhabitant
|} }.




Definition Capability_of_regval (merge_var : register_value) : option Capability :=
   match merge_var with | Regval_Capability v => Some v | _ => None end.

Definition regval_of_Capability (v : Capability) : register_value := Regval_Capability v.

Definition bit_of_regval (merge_var : register_value) : option bitU :=
   match merge_var with | Regval_bit v => Some v | _ => None end.

Definition regval_of_bit (v : bitU) : register_value := Regval_bit v.

Definition word_of_regval (merge_var : register_value) : option word :=
   match merge_var with | Regval_word v => Some v | _ => None end.

Definition regval_of_word (v : word) : register_value := Regval_word v.



Definition bool_of_regval (merge_var : register_value) : option bool :=
  match merge_var with | Regval_bool v => Some v | _ => None end.

Definition regval_of_bool (v : bool) : register_value := Regval_bool v.

Definition int_of_regval (merge_var : register_value) : option Z :=
  match merge_var with | Regval_int v => Some v | _ => None end.

Definition regval_of_int (v : Z) : register_value := Regval_int v.

Definition real_of_regval (merge_var : register_value) : option R :=
  match merge_var with | Regval_real v => Some v | _ => None end.

Definition regval_of_real (v : R) : register_value := Regval_real v.

Definition string_of_regval (merge_var : register_value) : option string :=
  match merge_var with | Regval_string v => Some v | _ => None end.

Definition regval_of_string (v : string) : register_value := Regval_string v.

Definition vector_of_regval {a} n (of_regval : register_value -> option a) (rv : register_value) : option (vec a n) := match rv with
  | Regval_vector v => if n =? length_list v then map_bind (vec_of_list n) (just_list (List.map of_regval v)) else None
  | _ => None
end.

Definition regval_of_vector {a size} (regval_of : a -> register_value) (xs : vec a size) : register_value := Regval_vector (List.map regval_of (list_of_vec xs)).

Definition list_of_regval {a} (of_regval : register_value -> option a) (rv : register_value) : option (list a) := match rv with
  | Regval_list v => just_list (List.map of_regval v)
  | _ => None
end.

Definition regval_of_list {a} (regval_of : a -> register_value) (xs : list a) : register_value := Regval_list (List.map regval_of xs).

Definition option_of_regval {a} (of_regval : register_value -> option a) (rv : register_value) : option (option a) := match rv with
  | Regval_option v => option_map of_regval v
  | _ => None
end.

Definition regval_of_option {a} (regval_of : a -> register_value) (v : option a) := Regval_option (option_map regval_of v).


Definition instr_count_ref := {|
  name := "instr_count";
  read_from := (fun s => s.(instr_count));
  write_to := (fun v s => ({[ s with instr_count := v ]}));
  of_regval := (fun v => int_of_regval v);
  regval_of := (fun v => regval_of_int v) |}.

Definition R3_ref := {|
  name := "R3";
  read_from := (fun s => s.(R3));
  write_to := (fun v s => ({[ s with R3 := v ]}));
  of_regval := (fun v => word_of_regval v);
  regval_of := (fun v => regval_of_word v) |}.

Definition R2_ref := {|
  name := "R2";
  read_from := (fun s => s.(R2));
  write_to := (fun v s => ({[ s with R2 := v ]}));
  of_regval := (fun v => word_of_regval v);
  regval_of := (fun v => regval_of_word v) |}.

Definition R1_ref := {|
  name := "R1";
  read_from := (fun s => s.(R1));
  write_to := (fun v s => ({[ s with R1 := v ]}));
  of_regval := (fun v => word_of_regval v);
  regval_of := (fun v => regval_of_word v) |}.

Definition R0_ref := {|
  name := "R0";
  read_from := (fun s => s.(R0));
  write_to := (fun v s => ({[ s with R0 := v ]}));
  of_regval := (fun v => word_of_regval v);
  regval_of := (fun v => regval_of_word v) |}.

Definition PC_ref := {|
  name := "PC";
  read_from := (fun s => s.(PC));
  write_to := (fun v s => ({[ s with PC := v ]}));
  of_regval := (fun v => Capability_of_regval v);
  regval_of := (fun v => regval_of_Capability v) |}.

Local Open Scope string.
Definition get_regval (reg_name : string) (s : regstate) : option register_value :=
  if string_dec reg_name "instr_count" then Some (instr_count_ref.(regval_of) (instr_count_ref.(read_from) s)) else
  if string_dec reg_name "R3" then Some (R3_ref.(regval_of) (R3_ref.(read_from) s)) else
  if string_dec reg_name "R2" then Some (R2_ref.(regval_of) (R2_ref.(read_from) s)) else
  if string_dec reg_name "R1" then Some (R1_ref.(regval_of) (R1_ref.(read_from) s)) else
  if string_dec reg_name "R0" then Some (R0_ref.(regval_of) (R0_ref.(read_from) s)) else
  if string_dec reg_name "PC" then Some (PC_ref.(regval_of) (PC_ref.(read_from) s)) else
  None.

Definition set_regval (reg_name : string) (v : register_value) (s : regstate) : option regstate :=
  if string_dec reg_name "instr_count" then option_map (fun v => instr_count_ref.(write_to) v s) (instr_count_ref.(of_regval) v) else
  if string_dec reg_name "R3" then option_map (fun v => R3_ref.(write_to) v s) (R3_ref.(of_regval) v) else
  if string_dec reg_name "R2" then option_map (fun v => R2_ref.(write_to) v s) (R2_ref.(of_regval) v) else
  if string_dec reg_name "R1" then option_map (fun v => R1_ref.(write_to) v s) (R1_ref.(of_regval) v) else
  if string_dec reg_name "R0" then option_map (fun v => R0_ref.(write_to) v s) (R0_ref.(of_regval) v) else
  if string_dec reg_name "PC" then option_map (fun v => PC_ref.(write_to) v s) (PC_ref.(of_regval) v) else
  None.

Definition register_accessors := (get_regval, set_regval).


Definition MR a r := monadR register_value a r exception.
Definition M a := monad register_value a exception.
Definition returnM {A:Type} := @returnm register_value A exception.
Definition returnR {A:Type} (R:Type) := @returnm register_value A (R + exception).